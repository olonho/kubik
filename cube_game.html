<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–æ–±–µ—Ä–∏ –ö—É–±–∏–∫–∏</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #instructions {
            position: absolute;
            top: 60px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            display: none;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9);
            text-align: center;
        }
        #restart {
            font-size: 24px;
            margin-top: 20px;
            padding: 10px 30px;
            cursor: pointer;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
        }
        #restart:hover {
            background-color: #45a049;
        }
        #changeSkin {
            font-size: 24px;
            margin-top: 20px;
            padding: 10px 30px;
            cursor: pointer;
            background-color: #FF9800;
            border: none;
            color: white;
            border-radius: 5px;
        }
        #changeSkin:hover {
            background-color: #F57C00;
        }
        #skinMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
        }
        #skinMenu h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 30px;
        }
        .skin-options {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        .skin-button {
            background-color: #fff;
            border: 3px solid #4CAF50;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 150px;
        }
        .skin-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }
        .skin-button h3 {
            margin: 10px 0 0 0;
            font-size: 20px;
            color: #333;
        }
        .skin-icon {
            font-size: 60px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="skinMenu">
        <h2>–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
        <div class="skin-options" style="flex-wrap: wrap; max-width: 800px; margin: 0 auto;">
            <div class="skin-button" onclick="selectSkin('dog')">
                <div class="skin-icon">üê∂</div>
                <h3>–°–æ–±–∞—á–∫–∞</h3>
            </div>
            <div class="skin-button" onclick="selectSkin('cat')">
                <div class="skin-icon">üê±</div>
                <h3>–ö–æ—à–µ—á–∫–∞</h3>
            </div>
            <div class="skin-button" onclick="selectSkin('fox')">
                <div class="skin-icon">ü¶ä</div>
                <h3>–õ–∏—Å–∏—á–∫–∞</h3>
            </div>
            <div class="skin-button" onclick="selectSkin('panda')">
                <div class="skin-icon">üêº</div>
                <h3>–ü–∞–Ω–¥–∞</h3>
            </div>
            <div class="skin-button" onclick="selectSkin('rabbit')">
                <div class="skin-icon">üê∞</div>
                <h3>–ó–∞–π—á–∏–∫</h3>
            </div>
            <div class="skin-button" onclick="selectSkin('robot')">
                <div class="skin-icon">ü§ñ</div>
                <h3>–†–æ–±–æ—Ç</h3>
            </div>
            <div class="skin-button" onclick="selectSkin('cube')">
                <div class="skin-icon">üü¶</div>
                <h3>–ö–≤–∞–¥—Ä–∞—Ç–∏–∫</h3>
            </div>
            <div class="skin-button" onclick="selectSkin('oval')">
                <div class="skin-icon">‚ö™</div>
                <h3>–û–≤–∞–ª</h3>
            </div>
        </div>
    </div>

    <div id="score" style="display: none;">–°—á—ë—Ç: 0 | –£—Ä–æ–≤–µ–Ω—å: 1 | –ñ–∏–∑–Ω–∏: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    <div id="instructions" style="display: none;">‚Üê ‚Üí : –î–≤–∏–∂–µ–Ω–∏–µ | –ü—Ä–æ–±–µ–ª: –ü—Ä—ã–∂–æ–∫ | W: –°—Ç—Ä–µ–ª—è—Ç—å | 1: –ü–∏—Å—Ç–æ–ª–µ—Ç | 2: –í–∏–Ω—Ç–æ–≤–∫–∞</div>
    <div id="weaponDisplay" style="display: none; position: absolute; top: 90px; left: 20px; color: white; font-size: 18px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 100;">
        –û—Ä—É–∂–∏–µ: üî´ –ü–∏—Å—Ç–æ–ª–µ—Ç
    </div>
    <div id="gameOver">
        <div>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</div>
        <div style="font-size: 24px; margin-top: 10px;">–í–∞—à —Å—á—ë—Ç: <span id="finalScore">0</span></div>
        <div style="font-size: 20px; margin-top: 5px;">–£—Ä–æ–≤–µ–Ω—å: <span id="finalLevel">1</span></div>
        <button id="restart">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        <button id="changeSkin" style="margin-left: 10px; background-color: #FF9800;">–°–º–µ–Ω–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let player, ground, currentWeapon;
        let obstacles = [];
        let bullets = [];
        let score = 0;
        let level = 1;
        let lives = 3;
        let gameActive = true;
        let playerVelocityY = 0;
        let isJumping = false;
        let keys = {};
        let selectedSkin = null;
        let selectedWeapon = 'pistol';
        let animationId = null;
        let decorations = [];
        let canShoot = true;
        let shootCooldown = 300;
        let playerDirection = 0;
        const gravity = -0.02;
        const jumpPower = 0.4;
        const playerSpeed = 0.15;
        const bulletSpeed = 0.5;
        let obstacleSpeed = 0.1;
        let spawnRate = 0.005;

        function selectSkin(skin) {
            selectedSkin = skin;

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã
            score = 0;
            level = 1;
            lives = 3;
            obstacleSpeed = 0.1;
            spawnRate = 0.005;
            playerVelocityY = 0;
            isJumping = false;
            gameActive = true;

            document.getElementById('skinMenu').style.display = 'none';
            document.getElementById('score').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            init();
        }

        function init() {
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—É—é –∞–Ω–∏–º–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤—ã
            obstacles = [];
            decorations = [];
            bullets = [];

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // –°–æ–∑–¥–∞—ë–º renderer —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ–≥–æ –µ—â–µ –Ω–µ—Ç
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(10, 100);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ä–µ–≤—å—è –ø–æ –∫—Ä–∞—è–º
            decorations = [];
            createTrees();

            // –°–æ–∑–¥–∞—ë–º –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–∫–∏–Ω–∞
            switch(selectedSkin) {
                case 'dog':
                    player = createDog();
                    break;
                case 'cat':
                    player = createCat();
                    break;
                case 'fox':
                    player = createFox();
                    break;
                case 'panda':
                    player = createPanda();
                    break;
                case 'rabbit':
                    player = createRabbit();
                    break;
                case 'robot':
                    player = createRobot();
                    break;
                case 'cube':
                    player = createCube();
                    break;
                case 'oval':
                    player = createOval();
                    break;
                default:
                    player = createDog();
            }
            player.position.set(0, 0.5, 0);

            scene.add(player);

            // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ä—É–∂–∏–µ –∫ –ø–µ—Ä—Å–æ–Ω–∞–∂—É
            currentWeapon = createWeapon(selectedWeapon);
            currentWeapon.position.set(0.6, 0.3, 0);
            currentWeapon.rotation.y = -Math.PI / 2;
            player.add(currentWeapon);

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º UI –æ—Ä—É–∂–∏—è
            document.getElementById('weaponDisplay').style.display = 'block';

            // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
            animate();
        }

        function createTrees() {
            // –î–µ—Ä–µ–≤—å—è —Å–ª–µ–≤–∞
            for (let i = 0; i < 15; i++) {
                const tree = createTree();
                tree.position.set(-5.5, 0, -i * 7 - 5);
                scene.add(tree);
                decorations.push(tree);
            }
            // –î–µ—Ä–µ–≤—å—è —Å–ø—Ä–∞–≤–∞
            for (let i = 0; i < 15; i++) {
                const tree = createTree();
                tree.position.set(5.5, 0, -i * 7 - 5);
                scene.add(tree);
                decorations.push(tree);
            }

            // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–º–Ω–∏
            for (let i = 0; i < 8; i++) {
                const rock = createRock();
                const side = Math.random() > 0.5 ? -6 : 6;
                rock.position.set(side, 0, -i * 12 - 10);
                scene.add(rock);
                decorations.push(rock);
            }

            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±–ª–∞–∫–∞
            for (let i = 0; i < 10; i++) {
                const cloud = createCloud();
                cloud.position.set((Math.random() - 0.5) * 20, 8 + Math.random() * 4, -i * 10 - 20);
                scene.add(cloud);
                decorations.push(cloud);
            }
        }

        function createTree() {
            const treeGroup = new THREE.Group();

            // –°—Ç–≤–æ–ª
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // –ö—Ä–æ–Ω–∞ (3 —Å—Ñ–µ—Ä—ã)
            const foliageGeometry = new THREE.SphereGeometry(0.8, 8, 8);
            const foliageMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });

            const foliage1 = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage1.position.y = 2.5;
            foliage1.castShadow = true;
            treeGroup.add(foliage1);

            const foliage2 = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage2.position.y = 3.2;
            foliage2.scale.set(0.8, 0.8, 0.8);
            foliage2.castShadow = true;
            treeGroup.add(foliage2);

            return treeGroup;
        }

        function createRock() {
            const geometry = new THREE.DodecahedronGeometry(0.5);
            const material = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const rock = new THREE.Mesh(geometry, material);
            rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            rock.scale.set(0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4);
            rock.castShadow = true;
            return rock;
        }

        function createCloud() {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });

            for (let i = 0; i < 3; i++) {
                const geometry = new THREE.SphereGeometry(0.5 + Math.random() * 0.3, 8, 8);
                const sphere = new THREE.Mesh(geometry, cloudMaterial);
                sphere.position.set((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 1);
                cloudGroup.add(sphere);
            }

            return cloudGroup;
        }

        function createDog() {
            const dogGroup = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.5);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xD2691E });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.3, 0);
            body.castShadow = true;
            dogGroup.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.35);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xD2691E });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.5, 0.4, 0);
            head.castShadow = true;
            dogGroup.add(head);

            // –ú–æ—Ä–¥–∞
            const snoutGeometry = new THREE.BoxGeometry(0.25, 0.2, 0.25);
            const snoutMaterial = new THREE.MeshPhongMaterial({ color: 0xCD853F });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0.72, 0.35, 0);
            snout.castShadow = true;
            dogGroup.add(snout);

            // –ù–æ—Å
            const noseGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0.84, 0.35, 0);
            nose.castShadow = true;
            dogGroup.add(nose);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.6, 0.5, -0.12);
            dogGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.6, 0.5, 0.12);
            dogGroup.add(rightEye);

            // –£—à–∏
            const earGeometry = new THREE.BoxGeometry(0.15, 0.3, 0.1);
            const earMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D });

            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(0.5, 0.65, -0.2);
            leftEar.rotation.z = 0.2;
            leftEar.castShadow = true;
            dogGroup.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.5, 0.65, 0.2);
            rightEar.rotation.z = -0.2;
            rightEar.castShadow = true;
            dogGroup.add(rightEar);

            // –õ–∞–ø—ã
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.35, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0xD2691E });

            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(0.3, 0.05, -0.2);
            frontLeftLeg.castShadow = true;
            dogGroup.add(frontLeftLeg);

            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.3, 0.05, 0.2);
            frontRightLeg.castShadow = true;
            dogGroup.add(frontRightLeg);

            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.3, 0.05, -0.2);
            backLeftLeg.castShadow = true;
            dogGroup.add(backLeftLeg);

            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(-0.3, 0.05, 0.2);
            backRightLeg.castShadow = true;
            dogGroup.add(backRightLeg);

            // –•–≤–æ—Å—Ç
            const tailGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.4, 8);
            const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.5, 0.4, 0);
            tail.rotation.z = Math.PI / 4;
            tail.castShadow = true;
            dogGroup.add(tail);

            return dogGroup;
        }

        function createCat() {
            const catGroup = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.5);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.3, 0);
            body.castShadow = true;
            catGroup.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.45, 0.45, 0);
            head.castShadow = true;
            catGroup.add(head);

            // –ú–æ—Ä–¥–æ—á–∫–∞
            const snoutGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const snoutMaterial = new THREE.MeshPhongMaterial({ color: 0xFFE4B5 });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0.65, 0.4, 0);
            snout.scale.set(0.8, 0.8, 0.6);
            snout.castShadow = true;
            catGroup.add(snout);

            // –ù–æ—Å
            const noseGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xFF69B4 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0.72, 0.4, 0);
            catGroup.add(nose);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.07, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x90EE90 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.58, 0.5, -0.12);
            catGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.58, 0.5, 0.12);
            catGroup.add(rightEye);

            // –ó—Ä–∞—á–∫–∏
            const pupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });

            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(0.64, 0.5, -0.12);
            catGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.64, 0.5, 0.12);
            catGroup.add(rightPupil);

            // –£—à–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–µ
            const earGeometry = new THREE.ConeGeometry(0.12, 0.25, 4);
            const earMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500 });

            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(0.45, 0.65, -0.15);
            leftEar.rotation.z = Math.PI;
            leftEar.castShadow = true;
            catGroup.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.45, 0.65, 0.15);
            rightEar.rotation.z = Math.PI;
            rightEar.castShadow = true;
            catGroup.add(rightEar);

            // –õ–∞–ø—ã
            const legGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.35, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500 });

            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(0.25, 0.05, -0.18);
            frontLeftLeg.castShadow = true;
            catGroup.add(frontLeftLeg);

            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.25, 0.05, 0.18);
            frontRightLeg.castShadow = true;
            catGroup.add(frontRightLeg);

            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.25, 0.05, -0.18);
            backLeftLeg.castShadow = true;
            catGroup.add(backLeftLeg);

            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(-0.25, 0.05, 0.18);
            backRightLeg.castShadow = true;
            catGroup.add(backRightLeg);

            // –•–≤–æ—Å—Ç (–≤—ã—à–µ –∏ –∏–∑–æ–≥–Ω—É—Ç—ã–π)
            const tailGeometry = new THREE.CylinderGeometry(0.04, 0.06, 0.5, 8);
            const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.5, 0.5, 0);
            tail.rotation.z = Math.PI / 3;
            tail.castShadow = true;
            catGroup.add(tail);

            return catGroup;
        }

        function createCube() {
            const cubeGroup = new THREE.Group();

            // –ü—Ä–æ—Å—Ç–æ –∫—É–±–∏–∫
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const material = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.y = 0.3;
            cube.castShadow = true;
            cubeGroup.add(cube);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.42, 0.4, -0.15);
            cubeGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.42, 0.4, 0.15);
            cubeGroup.add(rightEye);

            // –ó—Ä–∞—á–∫–∏
            const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });

            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(0.48, 0.4, -0.15);
            cubeGroup.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.48, 0.4, 0.15);
            cubeGroup.add(rightPupil);

            // –£–ª—ã–±–∫–∞
            const smileGeometry = new THREE.TorusGeometry(0.15, 0.02, 8, 16, Math.PI);
            const smileMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const smile = new THREE.Mesh(smileGeometry, smileMaterial);
            smile.position.set(0.42, 0.2, 0);
            smile.rotation.set(0, Math.PI / 2, 0);
            cubeGroup.add(smile);

            return cubeGroup;
        }

        function createOval() {
            const ovalGroup = new THREE.Group();

            // –¢–µ–ª–æ - —ç–ª–ª–∏–ø—Å–æ–∏–¥
            const bodyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.3;
            body.scale.set(1.2, 1, 0.8);
            body.castShadow = true;
            ovalGroup.add(body);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.4, 0.4, -0.12);
            ovalGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.4, 0.4, 0.12);
            ovalGroup.add(rightEye);

            // –†—É–º—è–Ω–µ—Ü
            const blushGeometry = new THREE.CircleGeometry(0.08, 16);
            const blushMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFB6C1,
                transparent: true,
                opacity: 0.6
            });

            const leftBlush = new THREE.Mesh(blushGeometry, blushMaterial);
            leftBlush.position.set(0.38, 0.3, -0.18);
            leftBlush.rotation.y = -Math.PI / 2;
            ovalGroup.add(leftBlush);

            const rightBlush = new THREE.Mesh(blushGeometry, blushMaterial);
            rightBlush.position.set(0.38, 0.3, 0.18);
            rightBlush.rotation.y = -Math.PI / 2;
            ovalGroup.add(rightBlush);

            // –£–ª—ã–±–∫–∞
            const smileGeometry = new THREE.TorusGeometry(0.12, 0.02, 8, 16, Math.PI);
            const smileMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const smile = new THREE.Mesh(smileGeometry, smileMaterial);
            smile.position.set(0.38, 0.22, 0);
            smile.rotation.set(0, Math.PI / 2, 0);
            ovalGroup.add(smile);

            // –ú–∞–ª–µ–Ω—å–∫–∏–µ —Ä—É—á–∫–∏
            const armGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(0, 0.3, -0.35);
            leftArm.scale.set(0.6, 1, 0.6);
            leftArm.castShadow = true;
            ovalGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0, 0.3, 0.35);
            rightArm.scale.set(0.6, 1, 0.6);
            rightArm.castShadow = true;
            ovalGroup.add(rightArm);

            return ovalGroup;
        }

        function createFox() {
            const foxGroup = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.5);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C00 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.3, 0);
            body.castShadow = true;
            foxGroup.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.BoxGeometry(0.4, 0.35, 0.35);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C00 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.5, 0.45, 0);
            head.castShadow = true;
            foxGroup.add(head);

            // –ú–æ—Ä–¥–∞ –±–µ–ª–∞—è
            const snoutGeometry = new THREE.BoxGeometry(0.2, 0.25, 0.3);
            const snoutMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0.68, 0.4, 0);
            snout.castShadow = true;
            foxGroup.add(snout);

            // –ù–æ—Å —á–µ—Ä–Ω—ã–π
            const noseGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0.78, 0.42, 0);
            foxGroup.add(nose);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.6, 0.52, -0.12);
            foxGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.6, 0.52, 0.12);
            foxGroup.add(rightEye);

            // –£—à–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–µ –±–æ–ª—å—à–∏–µ
            const earGeometry = new THREE.ConeGeometry(0.15, 0.3, 4);
            const earMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C00 });
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(0.5, 0.7, -0.15);
            leftEar.rotation.z = Math.PI;
            leftEar.castShadow = true;
            foxGroup.add(leftEar);
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.5, 0.7, 0.15);
            rightEar.rotation.z = Math.PI;
            rightEar.castShadow = true;
            foxGroup.add(rightEar);

            // –õ–∞–ø—ã
            const legGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.35, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C00 });
            for (let x of [0.25, -0.25]) {
                for (let z of [-0.18, 0.18]) {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 0.05, z);
                    leg.castShadow = true;
                    foxGroup.add(leg);
                }
            }

            // –•–≤–æ—Å—Ç –ø—É—à–∏—Å—Ç—ã–π
            const tailGeometry = new THREE.CylinderGeometry(0.06, 0.12, 0.6, 8);
            const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C00 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.6, 0.5, 0);
            tail.rotation.z = Math.PI / 2.5;
            tail.castShadow = true;
            foxGroup.add(tail);

            return foxGroup;
        }

        function createPanda() {
            const pandaGroup = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.35, 0);
            body.scale.set(1, 0.9, 0.8);
            body.castShadow = true;
            pandaGroup.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.3, 0.5, 0);
            head.castShadow = true;
            pandaGroup.add(head);

            // –ß–µ—Ä–Ω—ã–µ –ø—è—Ç–Ω–∞ –≤–æ–∫—Ä—É–≥ –≥–ª–∞–∑
            const patchGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const patchMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const leftPatch = new THREE.Mesh(patchGeometry, patchMaterial);
            leftPatch.position.set(0.42, 0.52, -0.15);
            leftPatch.scale.set(0.9, 1.2, 0.5);
            pandaGroup.add(leftPatch);
            const rightPatch = new THREE.Mesh(patchGeometry, patchMaterial);
            rightPatch.position.set(0.42, 0.52, 0.15);
            rightPatch.scale.set(0.9, 1.2, 0.5);
            pandaGroup.add(rightPatch);

            // –ì–ª–∞–∑–∞ –±–µ–ª—ã–µ
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.48, 0.52, -0.15);
            pandaGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.48, 0.52, 0.15);
            pandaGroup.add(rightEye);

            // –ó—Ä–∞—á–∫–∏
            const pupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(0.52, 0.52, -0.15);
            pandaGroup.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.52, 0.52, 0.15);
            pandaGroup.add(rightPupil);

            // –ù–æ—Å —á–µ—Ä–Ω—ã–π
            const noseGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0.55, 0.42, 0);
            pandaGroup.add(nose);

            // –£—à–∏ —á–µ—Ä–Ω—ã–µ –∫—Ä—É–≥–ª—ã–µ
            const earGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const earMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(0.3, 0.7, -0.2);
            leftEar.castShadow = true;
            pandaGroup.add(leftEar);
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.3, 0.7, 0.2);
            rightEar.castShadow = true;
            pandaGroup.add(rightEar);

            // –õ–∞–ø—ã —á–µ—Ä–Ω—ã–µ
            const legGeometry = new THREE.CylinderGeometry(0.09, 0.09, 0.35, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            for (let x of [0.2, -0.2]) {
                for (let z of [-0.25, 0.25]) {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 0.05, z);
                    leg.castShadow = true;
                    pandaGroup.add(leg);
                }
            }

            return pandaGroup;
        }

        function createRabbit() {
            const rabbitGroup = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.3, 0);
            body.scale.set(1, 1.1, 0.9);
            body.castShadow = true;
            rabbitGroup.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.35, 0.5, 0);
            head.castShadow = true;
            rabbitGroup.add(head);

            // –ú–æ—Ä–¥–∞
            const snoutGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const snoutMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0.55, 0.45, 0);
            snout.scale.set(0.8, 0.7, 0.6);
            rabbitGroup.add(snout);

            // –ù–æ—Å —Ä–æ–∑–æ–≤—ã–π
            const noseGeometry = new THREE.SphereGeometry(0.04, 8, 8);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xFFB6C1 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0.63, 0.46, 0);
            rabbitGroup.add(nose);

            // –ì–ª–∞–∑–∞
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.5, 0.55, -0.12);
            rabbitGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.5, 0.55, 0.12);
            rabbitGroup.add(rightEye);

            // –î–ª–∏–Ω–Ω—ã–µ —É—à–∏
            const earGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.08);
            const earMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(0.35, 0.9, -0.12);
            leftEar.rotation.z = 0.1;
            leftEar.castShadow = true;
            rabbitGroup.add(leftEar);
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.35, 0.9, 0.12);
            rightEar.rotation.z = -0.1;
            rightEar.castShadow = true;
            rabbitGroup.add(rightEar);

            // –õ–∞–ø—ã
            const legGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.25, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
            for (let x of [0.15, -0.15]) {
                for (let z of [-0.2, 0.2]) {
                    const leg = new THREE.Mesh(legGeometry, legMaterial);
                    leg.position.set(x, 0.05, z);
                    leg.castShadow = true;
                    rabbitGroup.add(leg);
                }
            }

            // –•–≤–æ—Å—Ç –ø—É—à–∏—Å—Ç—ã–π
            const tailGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.35, 0.3, 0);
            tail.castShadow = true;
            rabbitGroup.add(tail);

            return rabbitGroup;
        }

        function createRobot() {
            const robotGroup = new THREE.Group();

            // –¢–µ–ª–æ
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.7, 0.4);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080,
                metalness: 0.8,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.4, 0);
            body.castShadow = true;
            robotGroup.add(body);

            // –ì–æ–ª–æ–≤–∞
            const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.35);
            const headMaterial = new THREE.MeshPhongMaterial({
                color: 0xA9A9A9,
                metalness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.85, 0);
            head.castShadow = true;
            robotGroup.add(head);

            // –ê–Ω—Ç–µ–Ω–Ω–∞
            const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 8);
            const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.set(0, 1.12, 0);
            robotGroup.add(antenna);

            // –õ–∞–º–ø–æ—á–∫–∞ –Ω–∞ –∞–Ω—Ç–µ–Ω–Ω–µ
            const bulbGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const bulbMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 0.5
            });
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.position.set(0, 1.22, 0);
            robotGroup.add(bulb);

            // –ì–ª–∞–∑–∞ (—Å–≤–µ—Ç—è—â–∏–µ—Å—è)
            const eyeGeometry = new THREE.BoxGeometry(0.1, 0.08, 0.05);
            const eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x00FFFF,
                emissive: 0x00FFFF,
                emissiveIntensity: 0.7
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.21, 0.88, -0.1);
            robotGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.21, 0.88, 0.1);
            robotGroup.add(rightEye);

            // –†–æ—Ç
            const mouthGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.05);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0.21, 0.75, 0);
            robotGroup.add(mouth);

            // –†—É–∫–∏
            const armGeometry = new THREE.BoxGeometry(0.15, 0.5, 0.15);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(0, 0.35, -0.35);
            leftArm.castShadow = true;
            robotGroup.add(leftArm);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0, 0.35, 0.35);
            rightArm.castShadow = true;
            robotGroup.add(rightArm);

            // –ù–æ–≥–∏
            const legGeometry = new THREE.BoxGeometry(0.18, 0.35, 0.18);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x696969 });
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0, 0.075, -0.15);
            leftLeg.castShadow = true;
            robotGroup.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0, 0.075, 0.15);
            rightLeg.castShadow = true;
            robotGroup.add(rightLeg);

            return robotGroup;
        }

        function createPistol() {
            const pistolGroup = new THREE.Group();

            // –°—Ç–≤–æ–ª
            const barrelGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.35, 8);
            const barrelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.z = Math.PI / 2;
            barrel.castShadow = true;
            pistolGroup.add(barrel);

            // –ó–∞—Ç–≤–æ—Ä
            const slideGeometry = new THREE.BoxGeometry(0.25, 0.06, 0.06);
            const slideMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
            const slide = new THREE.Mesh(slideGeometry, slideMaterial);
            slide.position.set(0, 0.03, 0);
            slide.castShadow = true;
            pistolGroup.add(slide);

            // –†—É–∫–æ—è—Ç–∫–∞
            const gripGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.08);
            const gripMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const grip = new THREE.Mesh(gripGeometry, gripMaterial);
            grip.position.set(-0.08, -0.08, 0);
            grip.castShadow = true;
            pistolGroup.add(grip);

            // –ú—É—à–∫–∞
            const sightGeometry = new THREE.BoxGeometry(0.02, 0.04, 0.02);
            const sightMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFF00 });
            const sight = new THREE.Mesh(sightGeometry, sightMaterial);
            sight.position.set(0.15, 0.06, 0);
            pistolGroup.add(sight);

            return pistolGroup;
        }

        function createRifle() {
            const rifleGroup = new THREE.Group();

            // –î–ª–∏–Ω–Ω—ã–π —Å—Ç–≤–æ–ª
            const barrelGeometry = new THREE.CylinderGeometry(0.035, 0.035, 0.7, 8);
            const barrelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.z = Math.PI / 2;
            barrel.castShadow = true;
            rifleGroup.add(barrel);

            // –ö–æ—Ä–ø—É—Å
            const bodyGeometry = new THREE.BoxGeometry(0.35, 0.08, 0.1);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(-0.1, 0, 0);
            body.castShadow = true;
            rifleGroup.add(body);

            // –ü—Ä–∏–∫–ª–∞–¥
            const stockGeometry = new THREE.BoxGeometry(0.25, 0.1, 0.08);
            const stockMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const stock = new THREE.Mesh(stockGeometry, stockMaterial);
            stock.position.set(-0.35, -0.02, 0);
            stock.castShadow = true;
            rifleGroup.add(stock);

            // –†—É–∫–æ—è—Ç–∫–∞
            const gripGeometry = new THREE.BoxGeometry(0.06, 0.12, 0.06);
            const gripMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const grip = new THREE.Mesh(gripGeometry, gripMaterial);
            grip.position.set(-0.05, -0.09, 0);
            grip.castShadow = true;
            rifleGroup.add(grip);

            // –û–ø—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏—Ü–µ–ª
            const scopeBodyGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.15, 8);
            const scopeBodyMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const scopeBody = new THREE.Mesh(scopeBodyGeometry, scopeBodyMaterial);
            scopeBody.position.set(0.1, 0.08, 0);
            scopeBody.castShadow = true;
            rifleGroup.add(scopeBody);

            // –õ–∏–Ω–∑—ã –ø—Ä–∏—Ü–µ–ª–∞
            const lensGeometry = new THREE.CircleGeometry(0.035, 16);
            const lensMaterial = new THREE.MeshPhongMaterial({
                color: 0x4444FF,
                emissive: 0x0000FF,
                emissiveIntensity: 0.3
            });
            const lensFront = new THREE.Mesh(lensGeometry, lensMaterial);
            lensFront.position.set(0.175, 0.08, 0);
            lensFront.rotation.y = Math.PI / 2;
            rifleGroup.add(lensFront);

            // –ú—É—à–∫–∞
            const sightGeometry = new THREE.BoxGeometry(0.02, 0.05, 0.02);
            const sightMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
            const sight = new THREE.Mesh(sightGeometry, sightMaterial);
            sight.position.set(0.3, 0.04, 0);
            rifleGroup.add(sight);

            return rifleGroup;
        }

        function createWeapon(type) {
            if (type === 'pistol') {
                return createPistol();
            } else if (type === 'rifle') {
                return createRifle();
            }
            return createPistol();
        }

        function changeWeapon(weaponType) {
            if (selectedWeapon === weaponType) return;

            selectedWeapon = weaponType;

            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ –æ—Ä—É–∂–∏–µ
            if (currentWeapon) {
                player.remove(currentWeapon);
            }

            // –°–æ–∑–¥–∞–µ–º –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ –æ—Ä—É–∂–∏–µ
            currentWeapon = createWeapon(weaponType);
            currentWeapon.position.set(0.6, 0.3, 0);
            currentWeapon.rotation.y = -Math.PI / 2;
            player.add(currentWeapon);

            // –û–±–Ω–æ–≤–ª—è–µ–º UI –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–µ–ª—å–±—ã
            if (weaponType === 'pistol') {
                document.getElementById('weaponDisplay').textContent = '–û—Ä—É–∂–∏–µ: üî´ –ü–∏—Å—Ç–æ–ª–µ—Ç';
                shootCooldown = 300;
            } else if (weaponType === 'rifle') {
                document.getElementById('weaponDisplay').textContent = '–û—Ä—É–∂–∏–µ: üéØ –í–∏–Ω—Ç–æ–≤–∫–∞';
                shootCooldown = 500;
            }
        }

        function createObstacle() {
            const obstacleGroup = new THREE.Group();

            // –ö—É–±–∏–∫
            const size = 0.6;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshPhongMaterial({
                color: Math.random() * 0xffffff,
                emissive: Math.random() * 0x333333
            });
            const obstacle = new THREE.Mesh(geometry, material);
            const yPos = Math.random() * 2 + 0.8;
            obstacle.position.y = yPos;
            obstacle.castShadow = true;
            obstacle.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.1,
                y: (Math.random() - 0.5) * 0.1,
                z: (Math.random() - 0.5) * 0.1
            };
            obstacleGroup.add(obstacle);

            // –¢–µ–Ω—å-–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞ –∑–µ–º–ª–µ
            const shadowGeometry = new THREE.CircleGeometry(0.4, 16);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.3
            });
            const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.y = 0.01;
            obstacleGroup.add(shadow);

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è-–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
            const lineGeometry = new THREE.CylinderGeometry(0.02, 0.02, yPos, 8);
            const lineMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.2
            });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.y = yPos / 2;
            obstacleGroup.add(line);

            obstacleGroup.position.set((Math.random() - 0.5) * 5, 0, -50);
            obstacleGroup.userData.cube = obstacle;
            obstacleGroup.userData.line = line;
            obstacleGroup.rotationSpeed = obstacle.rotationSpeed;

            scene.add(obstacleGroup);
            obstacles.push(obstacleGroup);
        }

        function updatePlayer() {
            if (!gameActive) return;

            // –î–≤–∏–∂–µ–Ω–∏–µ –∏ –ø–æ–≤–æ—Ä–æ—Ç
            if (keys['ArrowLeft'] && player.position.x > -4) {
                player.position.x -= playerSpeed;
                playerDirection = -1;
                player.rotation.y = Math.PI / 2; // –ü–æ–≤–æ—Ä–æ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–ª–µ–≤–æ
            }
            if (keys['ArrowRight'] && player.position.x < 4) {
                player.position.x += playerSpeed;
                playerDirection = 1;
                player.rotation.y = -Math.PI / 2; // –ü–æ–≤–æ—Ä–æ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–ø—Ä–∞–≤–æ
            }
            // –í–æ–∑–≤—Ä–∞—Ç –≤ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ (–ª–∏—Ü–æ–º –≤–ø–µ—Ä–µ–¥)
            if (!keys['ArrowLeft'] && !keys['ArrowRight']) {
                playerDirection = 0;
                player.rotation.y = 0;
            }

            if (keys['Space'] && !isJumping) {
                playerVelocityY = jumpPower;
                isJumping = true;
            }

            // –°–º–µ–Ω–∞ –æ—Ä—É–∂–∏—è
            if (keys['Digit1']) {
                changeWeapon('pistol');
            }
            if (keys['Digit2']) {
                changeWeapon('rifle');
            }

            // –°—Ç—Ä–µ–ª—å–±–∞ –Ω–∞ –∫–ª–∞–≤–∏—à—É W
            if ((keys['KeyW'] || keys['KeyW'.toLowerCase()]) && canShoot) {
                shoot();
                canShoot = false;
                setTimeout(() => {
                    canShoot = true;
                }, shootCooldown);
            }

            playerVelocityY += gravity;
            player.position.y += playerVelocityY;

            if (player.position.y <= 0.5) {
                player.position.y = 0.5;
                playerVelocityY = 0;
                isJumping = false;
            }
        }

        function shoot() {
            const bulletGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const bulletMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.5
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.set(player.position.x, player.position.y, player.position.z - 1);
            bullet.castShadow = true;
            scene.add(bullet);
            bullets.push(bullet);
        }

        function updateBullets() {
            if (!gameActive) return;

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.z -= bulletSpeed;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    const obstacleGroup = obstacles[j];
                    const cube = obstacleGroup.userData.cube;
                    if (!cube) continue;

                    const cubeWorldPos = new THREE.Vector3();
                    cube.getWorldPosition(cubeWorldPos);

                    const distance = bullet.position.distanceTo(cubeWorldPos);
                    if (distance < 0.8) {
                        // –ü–æ–ø–∞–¥–∞–Ω–∏–µ!
                        scene.remove(obstacleGroup);
                        obstacles.splice(j, 1);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        score += 10;
                        updateLevel();
                        updateScoreDisplay();
                        break;
                    }
                }

                // –£–¥–∞–ª—è–µ–º –ø—É–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ –¥–∞–ª–µ–∫–æ
                if (bullet.position.z < -60) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }

        function updateScoreDisplay() {
            const heartsDisplay = '‚ù§Ô∏è'.repeat(lives);
            document.getElementById('score').textContent = '–°—á—ë—Ç: ' + score + ' | –£—Ä–æ–≤–µ–Ω—å: ' + level + ' | –ñ–∏–∑–Ω–∏: ' + heartsDisplay;
        }

        function loseLife() {
            lives--;
            updateScoreDisplay();

            // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ—Ç–µ—Ä–∏ –∂–∏–∑–Ω–∏ - –∫—Ä–∞—Å–Ω–∞—è –≤—Å–ø—ã—à–∫–∞
            scene.background = new THREE.Color(0xFF0000);
            setTimeout(() => {
                scene.background = new THREE.Color(0x87ceeb);
            }, 200);

            if (lives <= 0) {
                gameOver();
            }
        }

        function updateLevel() {
            const newLevel = Math.floor(score / 50) + 1;
            if (newLevel > level) {
                level = newLevel;
                obstacleSpeed = 0.1 + (level - 1) * 0.02;
                spawnRate = 0.005 + (level - 1) * 0.004;
                updateScoreDisplay();

                // –≠—Ñ—Ñ–µ–∫—Ç –ø—Ä–∏ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è
                scene.background = new THREE.Color(Math.random() * 0x666666 + 0x6699bb);
                setTimeout(() => {
                    scene.background = new THREE.Color(0x87ceeb);
                }, 300);
            }
        }

        function updateObstacles() {
            if (!gameActive) return;

            if (Math.random() < spawnRate) {
                createObstacle();
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacleGroup = obstacles[i];
                obstacleGroup.position.z += obstacleSpeed;

                // –í—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ –∫—É–±–∏–∫ –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã
                const cube = obstacleGroup.userData.cube;
                if (cube) {
                    cube.rotation.x += obstacleGroup.rotationSpeed.x;
                    cube.rotation.y += obstacleGroup.rotationSpeed.y;
                    cube.rotation.z += obstacleGroup.rotationSpeed.z;
                }

                if (checkCollision(player, obstacleGroup)) {
                    scene.remove(obstacleGroup);
                    obstacles.splice(i, 1);
                    score += 10;
                    updateLevel();
                    updateScoreDisplay();
                } else if (obstacleGroup.position.z > 10) {
                    scene.remove(obstacleGroup);
                    obstacles.splice(i, 1);
                    loseLife();
                }
            }
        }

        function checkCollision(obj1, obstacleGroup) {
            // –ü–æ–ª—É—á–∞–µ–º –º–∏—Ä–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –∫—É–±–∏–∫–∞ –≤ –≥—Ä—É–ø–ø–µ
            const cube = obstacleGroup.userData.cube;
            if (!cube) return false;

            const cubeWorldPos = new THREE.Vector3();
            cube.getWorldPosition(cubeWorldPos);

            const distance = obj1.position.distanceTo(cubeWorldPos);
            return distance < 1.2;
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            bullets.forEach(bullet => scene.remove(bullet));
            bullets = [];
            score = 0;
            level = 1;
            lives = 3;
            obstacleSpeed = 0.1;
            spawnRate = 0.005;
            canShoot = true;
            updateScoreDisplay();
            document.getElementById('gameOver').style.display = 'none';
            player.position.set(0, 0.5, 0);
            player.rotation.set(0, 0, 0);
            playerVelocityY = 0;
            isJumping = false;
            gameActive = true;
        }

        function returnToSkinMenu() {
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–≥—Ä—É
            gameActive = false;

            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã
            score = 0;
            level = 1;
            lives = 3;
            obstacleSpeed = 0.1;
            spawnRate = 0.005;
            playerVelocityY = 0;
            isJumping = false;
            canShoot = true;
            selectedSkin = null;

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Å–∫–∏–Ω–∞
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('score').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('skinMenu').style.display = 'block';
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            if (gameActive) {
                updatePlayer();
                updateObstacles();
                updateBullets();
            }
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º event listeners –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        document.getElementById('restart').addEventListener('click', restartGame);
        document.getElementById('changeSkin').addEventListener('click', returnToSkinMenu);

        // init() –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —Å–∫–∏–Ω–∞
    </script>
</body>
</html>
